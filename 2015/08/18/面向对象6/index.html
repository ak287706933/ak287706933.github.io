<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>面向对象(6) | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="一、函数的四种调用模式
函数有下列调用模式

函数调用模式
方法模式
构造器模式
上下文模式


函数的定义方式

声明式
表达式式
Function


单独独立调用的就是函数

函数名( 参数 )
this 表示全局对象
任何自调用函数都是函数模式


方法调用 模式   method

区分
方法本身就是函数, 但是方法不是单独独立的调用, 而是通过一个对象引导调用.


对象.方法( 参数">
<meta property="og:type" content="article">
<meta property="og:title" content="面向对象(6)">
<meta property="og:url" content="http://yoursite.com/2015/08/18/面向对象6/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="一、函数的四种调用模式
函数有下列调用模式

函数调用模式
方法模式
构造器模式
上下文模式


函数的定义方式

声明式
表达式式
Function


单独独立调用的就是函数

函数名( 参数 )
this 表示全局对象
任何自调用函数都是函数模式


方法调用 模式   method

区分
方法本身就是函数, 但是方法不是单独独立的调用, 而是通过一个对象引导调用.


对象.方法( 参数">
<meta property="og:updated_time" content="2017-02-14T07:00:56.124Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="面向对象(6)">
<meta name="twitter:description" content="一、函数的四种调用模式
函数有下列调用模式

函数调用模式
方法模式
构造器模式
上下文模式


函数的定义方式

声明式
表达式式
Function


单独独立调用的就是函数

函数名( 参数 )
this 表示全局对象
任何自调用函数都是函数模式


方法调用 模式   method

区分
方法本身就是函数, 但是方法不是单独独立的调用, 而是通过一个对象引导调用.


对象.方法( 参数">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-面向对象6" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/08/18/面向对象6/" class="article-date">
  <time datetime="2015-08-18T04:12:17.000Z" itemprop="datePublished">2015-08-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      面向对象(6)
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="一、函数的四种调用模式"><a href="#一、函数的四种调用模式" class="headerlink" title="一、函数的四种调用模式"></a>一、函数的四种调用模式</h4><ul>
<li><p>函数有下列调用模式</p>
<ul>
<li>函数调用模式</li>
<li>方法模式</li>
<li>构造器模式</li>
<li>上下文模式</li>
</ul>
</li>
<li><p>函数的定义方式</p>
<ul>
<li>声明式</li>
<li>表达式式</li>
<li>Function</li>
</ul>
</li>
<li><p>单独独立调用的就是函数</p>
<ul>
<li>函数名( 参数 )</li>
<li>this 表示全局对象</li>
<li>任何自调用函数都是函数模式</li>
</ul>
</li>
<li><p>方法调用 模式   method</p>
<ul>
<li>区分<ul>
<li>方法本身就是函数, 但是方法不是单独独立的调用, 而是通过一个对象引导调用.</li>
</ul>
</li>
<li>对象.方法( 参数 )<ul>
<li>this 表示引导方法的对象<ul>
<li>方法调用一定要有宿主对象，方法一定是某个对象的方法，对象可以是任何对象（非基本数据类型）</li>
<li>函数也是对象，也可以调用方法</li>
<li>方法调用, 常常称为静态方法</li>
</ul>
</li>
<li>o.func();</li>
<li>fn.func();</li>
<li>arr.func();</li>
<li>arr[n].func();</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="二、几种调用方式this的指向"><a href="#二、几种调用方式this的指向" class="headerlink" title="二、几种调用方式this的指向"></a>二、几种调用方式this的指向</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var length = 10;</div><div class="line">function fn() &#123;</div><div class="line">    console.log( this.length );</div><div class="line">&#125;</div><div class="line">var obj = &#123;</div><div class="line">    length: 5,</div><div class="line">    method: function ( fn ) &#123;</div><div class="line">        fn();//10 函数调用的this指向window</div><div class="line">        arguments[ 0 ]();//2 方法调用的this指向调用这个方法的对象arguments</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">obj.method( fn, 1 );</div></pre></td></tr></table></figure>
<h4 id="三、构造器模式-构造函数模式-构造方法模式"><a href="#三、构造器模式-构造函数模式-构造方法模式" class="headerlink" title="三、构造器模式(构造函数模式, 构造方法模式)"></a>三、构造器模式(构造函数模式, 构造方法模式)</h4><ul>
<li><p>constructor</p>
<ul>
<li>区分<ul>
<li>使用 new 关键字引导</li>
</ul>
</li>
<li><p>执行步骤</p>
<ul>
<li>var p = new Person();</li>
<li><p>new 是一个运算符, 专门用来申请创建对象(本质上就是申请一段内存), 创建出来的对象传递给构造函数的 this,利用构造函数对其初始化<br>new以后就创建了对象类似于{}，但是原型结构不同，其类型由构造函数决定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function Person () &#123;</div><div class="line">    this.name = &apos;jim&apos;;</div><div class="line">    this.age = 19;</div><div class="line">    this.gender = &apos;male&apos;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>理解:当new了一个新对象之后,this就等于这个新创建的对象,this.age等成员就相当于给新创建的对象加成员，完成赋值，依赖的原理是对象动态添加成员的特性(new 的过程会去创建一个空的对象，将这个新创建的空对象赋值给Person函数中的this，此时我们就可以通过this来访问这个新对象了，开始执行Person函数内部的代码；this现在是新创建的对象，所以我们给新创建的对象添加name属性为jack，age属性为20；如果Person函数中没有写return语句，那么默认返回新创建的对象this）<br>交给构造函数初始化</p>
</li>
</ul>
</li>
<li><p>var one={}；和构造器的原型不能</p>
</li>
<li><p>返回值</p>
<ul>
<li>如果不写 return 语句, 那么 构造函数 默认返回 this</li>
<li>如果在构造函数中写上 return 语句, 并紧跟基本类型( return num, return 1223 ). 则忽略返回类型. </li>
<li><p>如果在构造函数中写上 return 语句, 并且紧跟引用类型, 那么构造函数返回该引用类型数据, 而忽略 this</p>
</li>
<li><p>如果调用构造函数的时候, 构造函数没有参数, 圆括号是可以省略的<br>function Person(){return;this.age=18}</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="四、关于构造函数结合性的一个小结"><a href="#四、关于构造函数结合性的一个小结" class="headerlink" title="四、关于构造函数结合性的一个小结"></a>四、关于构造函数结合性的一个小结</h4><ul>
<li>如果构造函数没有参数, 可以省略 圆括号<ul>
<li>var p = new Person;</li>
</ul>
</li>
<li>如果希望创建对象并直接调用其方法<ul>
<li>( new Person () ).sayHello()</li>
<li>可以省略调整结合性的圆括号</li>
<li>new Person().sayHello()</li>
<li>如果想要省略构造函数的圆括号, 就必须添加结合性的圆括号</li>
<li>(new Person).sayHello()</li>
</ul>
</li>
</ul>
<h4 id="五、上下文调用模式"><a href="#五、上下文调用模式" class="headerlink" title="五、上下文调用模式"></a>五、上下文调用模式</h4><ul>
<li><p>就是 环境调用模式 =&gt; 在不同环境下的不同调用模式<br>*简单说就是统一一种格式, 可以实现 函数模式与方法模式</p>
</li>
<li><p>语法(区分)</p>
<ul>
<li>call 形式<ul>
<li>函数名.call( … )</li>
</ul>
</li>
<li>apply 形式<ul>
<li>函数名.apply( … )</li>
</ul>
</li>
<li>这两种形式功能完全一样, 唯一不同的是参数的形式. 首先学习 apply, 再来看  call形式</li>
</ul>
</li>
<li><p>用法</p>
<ul>
<li><p>存在上下文调用的目的就是为了实现借用方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function foo () &#123;</div><div class="line">    console.log( this );</div><div class="line">&#125;</div><div class="line">var o = &#123; name: &apos;jim&apos; &#125;;</div><div class="line">foo();</div><div class="line">o.func = foo;</div><div class="line">o.func();</div><div class="line">// 如果需要让函数以函数的形式调用, 可以使用</div><div class="line">foo.apply( null ) 或 foo.apply()</div><div class="line">// 如果希望他是方法调用模式, 注意需要提供一个宿主对象</div><div class="line">foo.apply( o )该方式调用，不会污染宿主对象，不必要宿主对象，必须包含该方法</div></pre></td></tr></table></figure>
</li>
<li><p>带有参数的函数如何实现上下文调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">        function foo ( num1, num2 ) &#123;</div><div class="line">            console.log( this );</div><div class="line">            return num1 + num2;</div><div class="line">        &#125; </div><div class="line">        // 函数调用模式</div><div class="line">        var res1 = foo( 123, 567 );</div><div class="line">        // 方法调用</div><div class="line">        var o = &#123; name: &apos;jim&apos; &#125;;</div><div class="line">        o.func = foo;</div><div class="line">        var res2 = o.func( 123, 567 );</div><div class="line">```   </div><div class="line">     * 使用 apply 进行调用, 如果函数是带有参数的. apply 的第一个参数要么是 null 要么是对象</div><div class="line">     * 如果是 null 就是函数调用, 如果是 对象就是 方法对象, 该对象就是宿主对象, 后面紧跟一个</div><div class="line">     * 数组参数, 将函数的参数依次放在数组中. </div><div class="line"></div><div class="line">        * 例如: 函数模式        foo( 123, 567 );</div><div class="line">              * apply         foo.apply( null, [ 123, 567 ] )</div><div class="line"></div><div class="line">     * 如果有一个函数调用: func( &apos;张三&apos;, 19, &apos;男&apos; ), 将其修改成 apply 模式</div><div class="line">        * func.apply( null, [ &apos;张三&apos;, 19, &apos;男&apos;] )</div><div class="line"></div><div class="line">        * 方法模式:           o.func( 123, 567 )</div><div class="line">        * apply               foo.apply( o, [ 123, 567 ] )</div><div class="line"></div><div class="line">     * 函数中的this到底是什么</div><div class="line">     * 函数中this是由调用函数的模式来决定的</div><div class="line"></div><div class="line">函数调用模式=》this：window</div><div class="line">方法调用模式=》this：调用方法的对象</div><div class="line">构造器调用模式=》this：new出来的那个对象</div><div class="line">上下文调用模式 this：apply或call方法的第一个参数，如果是null，this就是window，如果第一个参数是对象，this就是这个对象</div><div class="line"></div><div class="line">#### 六、call 调用</div><div class="line"> * 在使用 apply 调用的时候, 函数参数, 必须以数组的形式存在. 但是有些时候数组封装比较复杂</div><div class="line"> * 所以引入 call 调用, call 调用与 apply 完全相同, 唯一不同是是参数不需要使用数组</div><div class="line">赋值赋的是函数体，不包含宿主对象</div><div class="line"></div><div class="line">    foo( 123, 567 );</div><div class="line">    foo.apply( null, [ 123, 567 ] );</div><div class="line">    foo.call( null, 123, 567 );</div><div class="line"></div><div class="line">#### 七、借用构造方法实现继承</div></pre></td></tr></table></figure>
<p>function Person ( name, age, gender ) {<br> this.name = name;<br> this.age = age;<br> this.gender = gender;<br>}<br>function Student ( name, age, gender, course ) {<br> Person.call( this, name, age, gender );<br> this.course = course;<br>}<br>var p = new Student ( ‘jim’, 19, ‘male’, ‘前端’ );</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">10. 函数的 bind 方法</div><div class="line"> * bind 就是 绑定</div><div class="line">     * 就是让函数绑定对象的一种用法</div><div class="line">     * 函数本身就是可以调用, 但是其如果想要作为方法调用, 就必须传入宿主对象, 并且使用 call 或 apply 形式</div><div class="line">     *  但是 bind 使得我的函数可以与某一个对象绑定起来, 那么在调用函数的时候, 就好像是该对象在调用方法</div><div class="line"></div><div class="line"> * 语法</div><div class="line">     * 函数.bind( 对象 )   </div><div class="line">     * 返回一个函数 foo</div><div class="line">     * 那么调用 返回的函数 foo, 就好像 对象在调用 该方法一样</div><div class="line"></div><div class="line">11. Object.prototype 的成员</div><div class="line">    1) constructor</div><div class="line">    2) hasOwnProperty 判断该属性是否为自己提供</div><div class="line">    3) propertyIsEnumerable 判断属性是否可以枚举</div><div class="line">    4) isPrototypeOf    判断是否为原型对象</div><div class="line">    5) toString, toLocaleString, valueOf</div><div class="line"></div><div class="line">12. 包装对象</div><div class="line">    字符串 string 是基本类型, 理论上讲不应该包含方法</div><div class="line">    charAt, substr, slice, ...</div><div class="line"></div><div class="line">    在 js 中为了更好的使用数据, 为三个基本类型提供了对应的对象类型</div><div class="line"></div><div class="line">    Number</div><div class="line">    String</div><div class="line">    Boolean</div><div class="line"></div><div class="line">    在 开发中常常会使用基本数据类型, 但是基本数据类型没有方法, 因此 js 引擎会在需要的时候</div><div class="line">    自动的将基本类型转换成对象类型.</div><div class="line"></div><div class="line">    &quot;abc&quot;.charAt( 1 )</div><div class="line"></div><div class="line">    &quot;abc&quot; -&gt; new String( &quot;abc&quot; )</div><div class="line">    s.charAt( 1 ) 返回结果</div><div class="line">    s 就被销毁</div><div class="line"></div><div class="line">    当   基本类型.方法 的时候. 解释器首先将基本类型转换成对应的对象类型, 然后调用方法. </div><div class="line">    方法执行结束后, 这个对象就被立刻回收</div><div class="line"></div><div class="line">    在 apply 和 call 调用的时候, 也会有转换发生. 上下文调用的第一个参数必须是对象. 如果传递的是数字</div><div class="line">    就会自动转换成对应的包装类型</div><div class="line"></div><div class="line">13. getter 与 setter 的语法糖</div><div class="line"></div><div class="line">    语法糖: 为了方便开发而给出的语法结构</div></pre></td></tr></table></figure>
<p>var o = (function () {<br> var num = 123;<br> return {</p>
<pre><code>get_num: function () {
    return num;
},
set_num: function ( v ) {
    num = v;
}
</code></pre><p> };<br>})();</p>
<p>// 获得数据<br>o.get_num();            =&gt; o.num 形式</p>
<p>// 设置<br>o.set_num( 456 );       =&gt; o.num = 456 形式</p>
<p>var o = (function () {<br> var num = 123;<br> return {</p>
<pre><code>// get 名字 () { 逻辑体 }
get num () {
    return num;
}

// set 名字 ( v ) { 逻辑体 }
set num ( v ) {
    num = v;
}
</code></pre><p> };<br>})();<br>```</p>
<ol>
<li>ES5 中引入的部分数组方法<br>1&gt; forEach<br>2&gt; map<br>3&gt; filter<br>4&gt; some<br>5&gt; every<br>6&gt; indexOf<br>7&gt; lastIndexOf</li>
</ol>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/08/18/面向对象6/" data-id="ciyyhty7f000178ifolfp910d" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2015/08/19/面向对象7/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          面向对象(7)
        
      </div>
    </a>
  
  
    <a href="/2015/08/16/面向对象5/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">面向对象(5)</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">September 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">August 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">July 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/05/12/模块化开发/">模块化开发</a>
          </li>
        
          <li>
            <a href="/2015/12/15/css3高级/">css3动画与3D转换</a>
          </li>
        
          <li>
            <a href="/2015/12/12/css3进阶/">css3下</a>
          </li>
        
          <li>
            <a href="/2015/12/09/css3基础/">css3上</a>
          </li>
        
          <li>
            <a href="/2015/11/15/H5下/">h5下</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>